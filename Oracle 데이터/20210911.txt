select * from students;

select * from subjects;

select * from attendance;

--SQL 명령문 --> 

select *
from students t1 join attendance t2
on t1.SID = t2.SID
join subjects t3
on t2.subid = t3.subid
where t1.sid='S001'
and t2.subid = 'SUB1';


select * from attendance;

SELECT * FROM ATTENDANCE;

select T1.SNAME,T1.STEL,T1.SGENDER,t2.subid,t2.adate
from students t1, attendance t2
where t1.sid = t2.sid
;

create table MEM
(
    MID     CHAR(4)         NOT NULL    PRIMARY KEY,
    MNAME   VARCHAR2(100)   NOT NULL
);

INSERT INTO MEM VALUES('M001','홍길동');
INSERT INTO MEM VALUES('M002','전우치');
INSERT INTO MEM VALUES('M003','고길동');
INSERT INTO MEM VALUES('M004','나루토');

CREATE TABLE PD
(
    PID     CHAR(4)         NOT NULL    PRIMARY KEY,
    PNAME   VARCHAR2(100)   NOT NULL,
    PRICE   NUMBER(8,2)     NOT NULL
);
INSERT INTO PD VALUES('P001','새우깡', 200);
INSERT INTO PD VALUES('P002','아이스크림', 500);
INSERT INTO PD VALUES('P003','담배', 4500);
INSERT INTO PD VALUES('P004','초코바', 300);

--COMMIT;
CREATE TABLE BUY
(
    MID     CHAR(4)     NOT NULL,
    PID     CHAR(4)     NOT NULL,
    BPRICE  NUMBER(8,2)    NOT NULL,
    QTY  NUMBER(5)    NOT NULL,
    BDATE  VARCHAR2(8)    NOT NULL

);

INSERT INTO BUY VALUES('M001','P001',190,5, '20210901');
INSERT INTO BUY VALUES('M001','P002',470,7, '20210901');
INSERT INTO BUY VALUES('M002','P001',180,3, '20210901');
INSERT INTO BUY VALUES('M001','P001',170,5, '20210902');
INSERT INTO BUY VALUES('M002','P002',520,11, '20210902');
INSERT INTO BUY VALUES('M003','P002',530,9, '20210903');
INSERT INTO BUY VALUES('M001','P001',530,9, '20211003');

SELECT * FROM MEM;
SELECT * FROM PD;
SELECT * FROM BUY;

--1. 이름, 구매상품명, 가격, 개수, 날짜

SELECT T1.MNAME,t3.pname,t2.qty,t2.bdate,t2.bprice*t2.qty AS TPRICE
FROM MEM T1, BUY T2, PD T3
WHERE t1.mid=t2.mid
AND T2.PID=T3.PID
;

-- GROUP BY + 집계함수
-- FUNCTION과 METHOD의 차이 
-- FUNCTION : 반복하는 행위를 기능으로 만들고 버튼하나를 눌렀을때 그 기능을 나오게 하는 것을 FUNCTION이라고 함  
-- METHOD : CLASS상에서 작동하게 하는 것

-- SUM,AVG,COUNT
-- 회원별로 구매한 총가격
SELECT SUM(BPRICE) AS TOTALPRICE
FROM BUY
;

SELECT MID,SUM(BPRICE) FROM BUY
GROUP BY MID
;--MID를 기준으로 나눠주는 것


SELECT T1.MID,t2.mname,SUM(T1.BPRICE*qty), ROUND(AVG(T1.BPRICE*t1.qty),2) AS AVERAGE
        , COUNT(*)
FROM BUY T1, MEM T2
WHERE T1.MID=t2.mid
GROUP BY T1.MID,t2.mname
;

SELECT *
FROM MEM T2, BUY T1 --1대 다의 관계
WHERE T2.MID=t1.mid(+) --LEFT JOIN / 현재 줄에서 MEM(T2)이 왼쪽에 있기 때문에 MEM을 중심으로 데이터를 보여줌
AND T1.MID IS NULL
;

--한번도 안 팔린 물건 리스트
SELECT *
FROM BUY T2, PD T1
WHERE t1.pid=t2.pid(+)
AND T2.PID IS NULL
;

-- 상품별로 판매개수
SELECT T1.PID,t2.pname,SUM(t1.bprice*t1.qty) AS TPRICE,SUM(t1.qty),ROUND(AVG(BPRICE),2)
FROM BUY T1, PD T2
WHERE T1.PID=t2.pid
GROUP BY T1.PID,T2.PNAME
;

-- 상품별로 판매개수
SELECT * FROM
(SELECT t2.PNAME
        ,   NVL(SUM(T1.QTY),0) AS QTY
        ,   NVL(SUM(T1.BPRICE*T1.QTY),0) AS TPRICE
        ,   NVL(TO_CHAR(AVG(BPRICE),'안팔렸음') AS PRICE
    FROM PD T2 LEFT JOIN BUY T1
    ON T2.PID = T1.PID
    GROUP BY T2.PID, T2.PNAME
)
WHERE QTY >10
;
--쿼리 잘 기억하기
SELECT A.MID, A.MNAME, A.PID, A.PNAME, SUM(B.QTY),SUM(B.BPRICE*B.QTY)
FROM
(
    SELECT *
    FROM MEM T1, PD T2
    WHERE t1.MID='M001'--홍길동만 나타내고 싶을 때 
)A, BUY B
WHERE A.MID = B.MID(+)
AND A.PID = B.PID(+)
GROUP BY A.MID, A.MNAME, A.PID, A.PNAME
ORDER BY A.MID ASC
;


CREATE TABLE IN_SHOP
(
    IDX     NUMBER(5)      PRIMARY KEY,
    PID     CHAR(4)         NOT NULL,
    INPRICE NUMBER(9)       NOT NULL,
    INQTY   NUMBER(5)       NOT NULL,
    DID     CHAR(1)         NOT NULL

);

INSERT INTO IN_SHOP VALUES(1, 'P001', 145, 200, 'A');
INSERT INTO IN_SHOP VALUES(2, 'P002', 350, 100, 'B');
INSERT INTO IN_SHOP VALUES(3, 'P003', 4000, 200, 'B');
INSERT INTO IN_SHOP VALUES(4, 'P002', 360, 150, 'B');
INSERT INTO IN_SHOP VALUES(5, 'P001', 145, 200, 'A');
INSERT INTO IN_SHOP VALUES(6, 'P004', 710, 300, 'B');

SELECT * FROM PD;
--COMMIT;
--새우깡의 총매입개수
--각 상품별 총매입개수
SELECT T1.PID, t1.pname, SUM(INQTY)
FROM PD T1,IN_SHOP T2
WHERE T1.PID = T2.PID
GROUP BY T1.PID, T1.PNAME
;
--각 상품별 팔린 개수
SELECT T1.PID, t1.pname, SUM(QTY)
FROM PD T1,BUY T2
WHERE T1.PID = T2.PID
GROUP BY T1.PID, T1.PNAME
;

-- NVL 컬럼 값이 NULL값인 경우 특정값으로 출력
-- 열이름에 별명처럼 쓰고 싶을 때는 "",   
SELECT A.PID, A.PNAME, B.OUTQTY AS "판매개수",A.INQTY AS "입고" , A.INQTY-NVL(B.OUTQTY,0) AS RQTY
FROM
(
    SELECT T1.PID, t1.pname, SUM(INQTY) AS INQTY
    FROM PD T1,IN_SHOP T2
    WHERE T1.PID = T2.PID
    GROUP BY T1.PID, T1.PNAME
)A
,
(
    SELECT T1.PID, t1.pname, SUM(QTY) AS OUTQTY
    FROM PD T1,BUY T2
    WHERE T1.PID = T2.PID
    GROUP BY T1.PID, T1.PNAME
)B
WHERE A.PID = B.PID(+)

select * 
from
pd t1 left join buy t2
on t1.pid=t2.pid;
--where t2.pid is null


SELECT * FROM BUY;

SELECT PID, COUNT(*) FROM BUY
GROUP BY PID
HAVING COUNT(*)>1 --HAVING은 GROUP BY에 있는 PID 중에 HAVING에 적힌 조건을 만족하는 것들만 나타내도록 하는 것
;


SELECT '5' + '12' FROM DUAL;
SELECT 'M' || TO_CHAR(28, '0000') FROM DUAL;

SELECT 'M' || TRIM(TO_CHAR(28, 'FM0000')) FROM DUAL;
SELECT 'M' || TO_CHAR(28, 'FM0000') FROM DUAL;

SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY=MM=DD HH:MI:SS') FROM DUAL;

SELECT SYSDATE -1 FROM DUAL;

-- 9월1일부터 9월 30일까지 날짜별로 총 판매대금을 구해주세요

SELECT '2021-09-01',LEVEL, '2021-09-01' + LEVEL
FROM DUAL
CONNECT BY LEVEL <= 30
;
SELECT SYSDATE ,LEVEL, SYSDATE + LEVEL
FROM DUAL
CONNECT BY LEVEL <= 30
;
SELECT TO_DATE('2021-09-01'),LEVEL, TO_DATE('2021-09-01') + LEVEL
FROM DUAL
CONNECT BY LEVEL <= 30
;

SELECT TO_DATE('2021-09-01'),LEVEL, 
        TO_CHAR(TO_DATE('2021-09-01') + (LEVEL-1),'YYYYMMDD') AS BASICDATE
FROM DUAL
CONNECT BY LEVEL <= 30
;
--BUY 데이터를 날짜별로 총판매대금
SELECT bDATE,SUM(BPRICE*QTY)
FROM BUY
GROUP BY BDATE
;
----------------------------------------------------------------------
SELECT * FROM
(
    SELECT --TO_DATE('2021-09-01'),LEVEL, 
            TO_CHAR(TO_DATE('2021-01-01') + (LEVEL-1),'YYYYMMDD') AS BASICDATE
    FROM DUAL
    CONNECT BY LEVEL <= 365
)A
,
(
    SELECT bDATE,SUM(BPRICE*QTY)
    FROM BUY
    GROUP BY BDATE
)B
WHERE A.BASICDATE =b.bdate(+)
ORDER BY A.BASICDATE ASC

----------------------------------------------------------
SELECT TO_CHAR(SYSDATE, 'YYYY'),LEVEL
FROM DUAL
CONNECT BY LEVEL <=12


SELECT TO_CHAR(SYSDATE, 'YYYY')||TO_CHAR(LEVEL,'FM00')||'월'
FROM DUAL
CONNECT BY LEVEL <=12


SELECT bDATE,SUM(BPRICE*QTY)
FROM BUY
GROUP BY BDATE
;

SELECT TO_CHAR(TO_DATE(BDATE),'YYYYMM'),SUM(bPRICE*QTY)
FROM BUY
GROUP BY TO_CHAR(TO_DATE(BDATE),'YYYYMM')
;
--------------------------------
SELECT * FROM
(
    SELECT TO_CHAR(SYSDATE, 'YYYY')||TO_CHAR(LEVEL,'FM00') AS BASICDATE
    FROM DUAL
    CONNECT BY LEVEL <=12
)A
,
(
    SELECT TO_CHAR(TO_DATE(BDATE),'YYYYMM') AS BDATE,SUM(bPRICE*QTY)
    FROM BUY
    GROUP BY TO_CHAR(TO_DATE(BDATE),'YYYYMM')
)B
WHERE A.BASICDATE = b.bdate(+)
ORDER BY A.BASICDATE ASC

MSSQL, ORACLE -- 날짜함수

